/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * Heads or Tails PvP dApp API
 * API for the PvP Heads or Tails decentralized application on Axiome Chain. Enables creating, accepting, revealing, and resolving Heads/Tails bets with LAUNCH tokens.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import { customFetch } from '../custom-fetch';
/**
 * Maker display nickname
 */
export type BetMakerNickname = string | null;

/**
 * Current bet status
 */
export type BetStatus = typeof BetStatus[keyof typeof BetStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BetStatus = {
  open: 'open',
  accepting: 'accepting',
  accepted: 'accepted',
  revealed: 'revealed',
  canceled: 'canceled',
  timeout_claimed: 'timeout_claimed',
} as const;

/**
 * Acceptor address (null if OPEN)
 * @minLength 1
 */
export type BetAcceptor = string | null;

/**
 * Acceptor display nickname
 */
export type BetAcceptorNickname = string | null;

/**
 * Acceptor guess (null if OPEN)
 */
export type BetAcceptorGuess = 'heads' | 'tails' | null;

export type BetAcceptedAt = string | null;

/**
 * Transaction hash
 */
export type BetTxhashAccept = string | null;

/**
 * Maker revealed side
 */
export type BetRevealSide = 'heads' | 'tails' | null;

/**
 * Winner address
 * @minLength 1
 */
export type BetWinner = string | null;

/**
 * Winner display nickname
 */
export type BetWinnerNickname = string | null;

/**
 * Winner payout (after commission)
 * @pattern ^\d+$
 */
export type BetPayoutAmount = string | null;

/**
 * Token amount as string
 * @pattern ^\d+$
 */
export type BetCommissionAmount = string | null;

export type BetResolvedAt = string | null;

/**
 * Transaction hash
 */
export type BetTxhashResolve = string | null;

/**
 * Deadline for maker to reveal (accepted_at + 5min)
 */
export type BetRevealDeadline = string | null;

/**
 * When open bet expires (created_at + TTL)
 */
export type BetExpiresAt = string | null;

export interface Bet {
  /**
   * Unique bet identifier
   */
  id: number;
  /**
   * Axiome wallet address
   * @minLength 1
   */
  maker: string;
  /** Maker display nickname */
  maker_nickname: BetMakerNickname;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  amount: string;
  /** Current bet status */
  status: BetStatus;
  /** Bet creation time (ISO 8601) */
  created_at: string;
  /** Transaction hash */
  txhash_create: string;
  /**
   * Acceptor address (null if OPEN)
   * @minLength 1
   */
  acceptor: BetAcceptor;
  /** Acceptor display nickname */
  acceptor_nickname: BetAcceptorNickname;
  /** Acceptor guess (null if OPEN) */
  acceptor_guess: BetAcceptorGuess;
  accepted_at: BetAcceptedAt;
  /** Transaction hash */
  txhash_accept: BetTxhashAccept;
  /** Maker revealed side */
  reveal_side: BetRevealSide;
  /**
   * Winner address
   * @minLength 1
   */
  winner: BetWinner;
  /** Winner display nickname */
  winner_nickname: BetWinnerNickname;
  /**
   * Winner payout (after commission)
   * @pattern ^\d+$
   */
  payout_amount: BetPayoutAmount;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  commission_amount: BetCommissionAmount;
  resolved_at: BetResolvedAt;
  /** Transaction hash */
  txhash_resolve: BetTxhashResolve;
  /** Deadline for maker to reveal (accepted_at + 5min) */
  reveal_deadline: BetRevealDeadline;
  /** When open bet expires (created_at + TTL) */
  expires_at: BetExpiresAt;
}

export interface CreateBetRequest {
  /**
   * Bet amount in LAUNCH tokens
   * @pattern ^\d+$
   */
  amount: string;
}

/**
 * Additional error details
 */
export type ErrorResponseErrorDetails = {[key: string]: unknown};

export type ErrorResponseError = {
  /** Machine-readable error code */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  details?: ErrorResponseErrorDetails;
};

export interface ErrorResponse {
  error: ErrorResponseError;
}

/**
 * Acceptor guess: heads or tails
 */
export type AcceptBetRequestGuess = typeof AcceptBetRequestGuess[keyof typeof AcceptBetRequestGuess];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AcceptBetRequestGuess = {
  heads: 'heads',
  tails: 'tails',
} as const;

export interface AcceptBetRequest {
  /** Acceptor guess: heads or tails */
  guess: AcceptBetRequestGuess;
}

/**
 * Maker original chosen side
 */
export type RevealRequestSide = typeof RevealRequestSide[keyof typeof RevealRequestSide];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RevealRequestSide = {
  heads: 'heads',
  tails: 'tails',
} as const;

export interface RevealRequest {
  /** Maker original chosen side */
  side: RevealRequestSide;
  /**
   * Original secret (64 hex chars = 32 bytes)
   * @minLength 64
   * @maxLength 64
   */
  secret: string;
}

export interface VaultBalance {
  /**
   * Available balance (not locked)
   * @pattern ^\d+$
   */
  available: string;
  /**
   * Locked in active bets
   * @pattern ^\d+$
   */
  locked: string;
  /**
   * Total vault balance
   * @pattern ^\d+$
   */
  total: string;
}

export interface DepositRequest {
  /**
   * Amount of LAUNCH to deposit
   * @pattern ^\d+$
   */
  amount: string;
}

export interface WithdrawRequest {
  /**
   * Amount of LAUNCH to withdraw
   * @pattern ^\d+$
   */
  amount: string;
}

/**
 * Display name
 */
export type UserProfileNickname = string | null;

/**
 * Avatar image URL
 */
export type UserProfileAvatarUrl = string | null;

export type UserProfileStats = {
  /** Total bets placed */
  total_bets: number;
  /** Total wins */
  wins: number;
  /** Total losses */
  losses: number;
  /**
   * Total LAUNCH wagered
   * @pattern ^\d+$
   */
  total_wagered: string;
  /**
   * Total LAUNCH won
   * @pattern ^\d+$
   */
  total_won: string;
};

/**
 * Authz grant expiration
 */
export type UserProfileAuthzExpiresAt = string | null;

export interface UserProfile {
  /**
   * Axiome wallet address
   * @minLength 1
   */
  address: string;
  /** Display name */
  nickname: UserProfileNickname;
  /** Avatar image URL */
  avatar_url: UserProfileAvatarUrl;
  stats: UserProfileStats;
  /** 1-click mode active */
  authz_enabled: boolean;
  /** Authz grant expiration */
  authz_expires_at: UserProfileAuthzExpiresAt;
  /** Gas sponsorship active */
  fee_sponsored: boolean;
}

export type LeaderboardEntryNickname = string | null;

export interface LeaderboardEntry {
  rank: number;
  /**
   * Axiome wallet address
   * @minLength 1
   */
  address: string;
  nickname: LeaderboardEntryNickname;
  wins: number;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  total_wagered: string;
  /** Win rate 0-1 */
  win_rate: number;
}

export interface ConnectRequest {
  /**
   * User wallet address
   * @minLength 1
   */
  address: string;
  /** Signed message proving ownership */
  signature?: string;
  /** Original signed message */
  message?: string;
}

export type GrantStatusAuthzExpiresAt = string | null;

export type GrantStatusAuthzCallsRemaining = number | null;

/**
 * Remaining daily fee allowance
 */
export type GrantStatusFeeGrantDailyRemaining = string | null;

export interface GrantStatus {
  /** Authz grant exists and is valid */
  authz_granted: boolean;
  authz_expires_at: GrantStatusAuthzExpiresAt;
  authz_calls_remaining: GrantStatusAuthzCallsRemaining;
  /** Feegrant is active */
  fee_grant_active: boolean;
  /** Remaining daily fee allowance */
  fee_grant_daily_remaining: GrantStatusFeeGrantDailyRemaining;
}

/**
 * Event type
 */
export type EventResponseType = typeof EventResponseType[keyof typeof EventResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventResponseType = {
  contest: 'contest',
  raffle: 'raffle',
} as const;

export type EventResponseDescription = string | null;

/**
 * Event lifecycle status
 */
export type EventResponseStatus = typeof EventResponseStatus[keyof typeof EventResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventResponseStatus = {
  draft: 'draft',
  active: 'active',
  calculating: 'calculating',
  completed: 'completed',
  archived: 'archived',
} as const;

export type EventResponseConfig = {[key: string]: unknown};

export type EventResponseResultsAnyOf = {[key: string]: unknown};

export type EventResponseResults = EventResponseResultsAnyOf | null;

export type EventResponseRaffleSeed = string | null;

export type EventResponseMyRank = number | null;

export interface EventResponse {
  id: string;
  /** Event type */
  type: EventResponseType;
  title: string;
  description: EventResponseDescription;
  /** Event lifecycle status */
  status: EventResponseStatus;
  startsAt: string;
  endsAt: string;
  config: EventResponseConfig;
  prizes: PrizeEntry[];
  totalPrizePool: string;
  results: EventResponseResults;
  raffleSeed: EventResponseRaffleSeed;
  participantCount: number;
  hasJoined?: boolean;
  myRank?: EventResponseMyRank;
  createdAt: string;
}

export interface PrizeEntry {
  /**
   * Prize place (1st, 2nd, etc.)
   * @minimum 1
   */
  place: number;
  /**
   * Prize amount in micro-LAUNCH
   * @pattern ^\d+$
   */
  amount: string;
  /** Display label for this prize tier */
  label?: string;
}

export type EventLeaderboardEntryNickname = string | null;

export type EventLeaderboardEntryPrizeAmount = string | null;

export interface EventLeaderboardEntry {
  rank: number;
  userId: string;
  address: string;
  nickname: EventLeaderboardEntryNickname;
  turnover: string;
  wins: number;
  profit: string;
  games: number;
  prizeAmount: EventLeaderboardEntryPrizeAmount;
}

export type EventParticipantNickname = string | null;

export type EventParticipantFinalRank = number | null;

export type EventParticipantPrizeAmount = string | null;

export interface EventParticipant {
  userId: string;
  address: string;
  nickname: EventParticipantNickname;
  status: string;
  joinedAt: string;
  finalRank: EventParticipantFinalRank;
  prizeAmount: EventParticipantPrizeAmount;
}

export type GetBetsParams = {
status?: GetBetsStatus;
min_amount?: string;
max_amount?: string;
cursor?: string;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type GetBetsStatus = typeof GetBetsStatus[keyof typeof GetBetsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetBetsStatus = {
  open: 'open',
  accepting: 'accepting',
  accepted: 'accepted',
  revealed: 'revealed',
  canceled: 'canceled',
  timeout_claimed: 'timeout_claimed',
} as const;

export type GetBets200Cursor = string | null;

export type GetBets200 = {
  data: Bet[];
  cursor: GetBets200Cursor;
  has_more: boolean;
};

export type CreateBet201 = {
  data: Bet;
};

export type GetBetHistoryParams = {
address?: string;
cursor?: string;
limit?: number;
};

export type GetBetHistory200Cursor = string | null;

export type GetBetHistory200 = {
  data: Bet[];
  cursor: GetBetHistory200Cursor;
  has_more: boolean;
};

export type GetBetById200 = {
  data: Bet;
};

export type AcceptBet200 = {
  data: Bet;
};

export type RevealBet200 = {
  data: Bet;
};

export type CancelBet200 = {
  data: Bet;
};

export type ClaimTimeout200 = {
  data: Bet;
};

export type GetVaultBalance200 = {
  data: VaultBalance;
};

export type GetCurrentUser200 = {
  data: UserProfile;
};

export type GetUserByAddress200 = {
  data: UserProfile;
};

export type GetLeaderboardParams = {
cursor?: string;
limit?: number;
};

export type GetLeaderboard200Cursor = string | null;

export type GetLeaderboard200 = {
  data: LeaderboardEntry[];
  cursor: GetLeaderboard200Cursor;
  has_more: boolean;
};

export type GetGrantStatus200 = {
  data: GrantStatus;
};

export type GetActiveEvents200 = {
  data: EventResponse[];
};

export type GetCompletedEventsParams = {
limit?: number;
offset?: number;
};

export type GetCompletedEvents200 = {
  data: EventResponse[];
};

export type GetEventById200 = {
  data: EventResponse;
};

export type GetEventLeaderboardParams = {
limit?: number;
offset?: number;
};

export type GetEventLeaderboard200 = {
  data: EventLeaderboardEntry[];
  total: number;
};

export type GetEventParticipantsParams = {
limit?: number;
offset?: number;
};

export type GetEventParticipants200 = {
  data: EventParticipant[];
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List open bets
 */
export const getBets = (
    params?: GetBetsParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBets200>(
      {url: `/api/v1/bets`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetBetsQueryKey = (params?: GetBetsParams,) => {
    return [
    `/api/v1/bets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetBetsQueryOptions = <TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBets>>> = ({ signal }) => getBets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetsQueryResult = NonNullable<Awaited<ReturnType<typeof getBets>>>
export type GetBetsQueryError = unknown


export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params: undefined |  GetBetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBets>>,
          TError,
          Awaited<ReturnType<typeof getBets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBets>>,
          TError,
          Awaited<ReturnType<typeof getBets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List open bets
 */

export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBets>>> = ({ signal }) => getBets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBets>>>
export type GetBetsSuspenseQueryError = unknown


export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params: undefined |  GetBetsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List open bets
 */

export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetsSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new bet
 */
export const createBet = (
    createBetRequest: CreateBetRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CreateBet201>(
      {url: `/api/v1/bets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBetRequest, signal
    },
      options);
    }
  


export const getCreateBetMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext> => {

const mutationKey = ['createBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBet>>, {data: CreateBetRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBet(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBetMutationResult = NonNullable<Awaited<ReturnType<typeof createBet>>>
    export type CreateBetMutationBody = CreateBetRequest
    export type CreateBetMutationError = ErrorResponse

    /**
 * @summary Create a new bet
 */
export const useCreateBet = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBet>>,
        TError,
        {data: CreateBetRequest},
        TContext
      > => {

      const mutationOptions = getCreateBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get bet history
 */
export const getBetHistory = (
    params?: GetBetHistoryParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBetHistory200>(
      {url: `/api/v1/bets/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetBetHistoryQueryKey = (params?: GetBetHistoryParams,) => {
    return [
    `/api/v1/bets/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetBetHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetHistory>>> = ({ signal }) => getBetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getBetHistory>>>
export type GetBetHistoryQueryError = unknown


export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params: undefined |  GetBetHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetHistory>>,
          TError,
          Awaited<ReturnType<typeof getBetHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetHistory>>,
          TError,
          Awaited<ReturnType<typeof getBetHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet history
 */

export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetHistorySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetHistory>>> = ({ signal }) => getBetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetHistorySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBetHistory>>>
export type GetBetHistorySuspenseQueryError = unknown


export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params: undefined |  GetBetHistoryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet history
 */

export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetHistorySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get bet details
 */
export const getBetById = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBetById200>(
      {url: `/api/v1/bets/${betId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetBetByIdQueryKey = (betId?: number,) => {
    return [
    `/api/v1/bets/${betId}`
    ] as const;
    }

    
export const getGetBetByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetByIdQueryKey(betId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetById>>> = ({ signal }) => getBetById(betId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(betId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBetById>>>
export type GetBetByIdQueryError = ErrorResponse


export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetById>>,
          TError,
          Awaited<ReturnType<typeof getBetById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetById>>,
          TError,
          Awaited<ReturnType<typeof getBetById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet details
 */

export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetByIdQueryOptions(betId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetByIdQueryKey(betId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetById>>> = ({ signal }) => getBetById(betId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBetById>>>
export type GetBetByIdSuspenseQueryError = ErrorResponse


export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet details
 */

export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetByIdSuspenseQueryOptions(betId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Accept an open bet
 */
export const acceptBet = (
    betId: number,
    acceptBetRequest: AcceptBetRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<AcceptBet200>(
      {url: `/api/v1/bets/${betId}/accept`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: acceptBetRequest, signal
    },
      options);
    }
  


export const getAcceptBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext> => {

const mutationKey = ['acceptBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptBet>>, {betId: number;data: AcceptBetRequest}> = (props) => {
          const {betId,data} = props ?? {};

          return  acceptBet(betId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AcceptBetMutationResult = NonNullable<Awaited<ReturnType<typeof acceptBet>>>
    export type AcceptBetMutationBody = AcceptBetRequest
    export type AcceptBetMutationError = unknown

    /**
 * @summary Accept an open bet
 */
export const useAcceptBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof acceptBet>>,
        TError,
        {betId: number;data: AcceptBetRequest},
        TContext
      > => {

      const mutationOptions = getAcceptBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Reveal commitment for accepted bet
 */
export const revealBet = (
    betId: number,
    revealRequest: RevealRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<RevealBet200>(
      {url: `/api/v1/bets/${betId}/reveal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: revealRequest, signal
    },
      options);
    }
  


export const getRevealBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext> => {

const mutationKey = ['revealBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof revealBet>>, {betId: number;data: RevealRequest}> = (props) => {
          const {betId,data} = props ?? {};

          return  revealBet(betId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RevealBetMutationResult = NonNullable<Awaited<ReturnType<typeof revealBet>>>
    export type RevealBetMutationBody = RevealRequest
    export type RevealBetMutationError = unknown

    /**
 * @summary Reveal commitment for accepted bet
 */
export const useRevealBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof revealBet>>,
        TError,
        {betId: number;data: RevealRequest},
        TContext
      > => {

      const mutationOptions = getRevealBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Cancel an open bet
 */
export const cancelBet = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CancelBet200>(
      {url: `/api/v1/bets/${betId}/cancel`, method: 'POST', signal
    },
      options);
    }
  


export const getCancelBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext> => {

const mutationKey = ['cancelBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelBet>>, {betId: number}> = (props) => {
          const {betId} = props ?? {};

          return  cancelBet(betId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelBetMutationResult = NonNullable<Awaited<ReturnType<typeof cancelBet>>>
    
    export type CancelBetMutationError = unknown

    /**
 * @summary Cancel an open bet
 */
export const useCancelBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelBet>>,
        TError,
        {betId: number},
        TContext
      > => {

      const mutationOptions = getCancelBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Claim timeout on unrevealed bet
 */
export const claimTimeout = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<ClaimTimeout200>(
      {url: `/api/v1/bets/${betId}/claim-timeout`, method: 'POST', signal
    },
      options);
    }
  


export const getClaimTimeoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext> => {

const mutationKey = ['claimTimeout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof claimTimeout>>, {betId: number}> = (props) => {
          const {betId} = props ?? {};

          return  claimTimeout(betId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClaimTimeoutMutationResult = NonNullable<Awaited<ReturnType<typeof claimTimeout>>>
    
    export type ClaimTimeoutMutationError = unknown

    /**
 * @summary Claim timeout on unrevealed bet
 */
export const useClaimTimeout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof claimTimeout>>,
        TError,
        {betId: number},
        TContext
      > => {

      const mutationOptions = getClaimTimeoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current vault balance
 */
export const getVaultBalance = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetVaultBalance200>(
      {url: `/api/v1/vault/balance`, method: 'GET', signal
    },
      options);
    }
  



export const getGetVaultBalanceQueryKey = () => {
    return [
    `/api/v1/vault/balance`
    ] as const;
    }

    
export const getGetVaultBalanceQueryOptions = <TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVaultBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVaultBalance>>> = ({ signal }) => getVaultBalance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVaultBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getVaultBalance>>>
export type GetVaultBalanceQueryError = unknown


export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVaultBalance>>,
          TError,
          Awaited<ReturnType<typeof getVaultBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVaultBalance>>,
          TError,
          Awaited<ReturnType<typeof getVaultBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current vault balance
 */

export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVaultBalanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetVaultBalanceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVaultBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVaultBalance>>> = ({ signal }) => getVaultBalance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVaultBalanceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getVaultBalance>>>
export type GetVaultBalanceSuspenseQueryError = unknown


export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current vault balance
 */

export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVaultBalanceSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initiate deposit (returns Axiome Connect payload)
 */
export const depositToVault = (
    depositRequest: DepositRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/vault/deposit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: depositRequest, signal
    },
      options);
    }
  


export const getDepositToVaultMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext> => {

const mutationKey = ['depositToVault'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof depositToVault>>, {data: DepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  depositToVault(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DepositToVaultMutationResult = NonNullable<Awaited<ReturnType<typeof depositToVault>>>
    export type DepositToVaultMutationBody = DepositRequest
    export type DepositToVaultMutationError = unknown

    /**
 * @summary Initiate deposit (returns Axiome Connect payload)
 */
export const useDepositToVault = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof depositToVault>>,
        TError,
        {data: DepositRequest},
        TContext
      > => {

      const mutationOptions = getDepositToVaultMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Withdraw LAUNCH from vault
 */
export const withdrawFromVault = (
    withdrawRequest: WithdrawRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/vault/withdraw`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: withdrawRequest, signal
    },
      options);
    }
  


export const getWithdrawFromVaultMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext> => {

const mutationKey = ['withdrawFromVault'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdrawFromVault>>, {data: WithdrawRequest}> = (props) => {
          const {data} = props ?? {};

          return  withdrawFromVault(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawFromVaultMutationResult = NonNullable<Awaited<ReturnType<typeof withdrawFromVault>>>
    export type WithdrawFromVaultMutationBody = WithdrawRequest
    export type WithdrawFromVaultMutationError = unknown

    /**
 * @summary Withdraw LAUNCH from vault
 */
export const useWithdrawFromVault = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdrawFromVault>>,
        TError,
        {data: WithdrawRequest},
        TContext
      > => {

      const mutationOptions = getWithdrawFromVaultMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current user profile
 */
export const getCurrentUser = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetCurrentUser200>(
      {url: `/api/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/v1/users/me`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = unknown


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user profile
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetCurrentUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserSuspenseQueryError = unknown


export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user profile
 */

export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get public user profile
 */
export const getUserByAddress = (
    address: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetUserByAddress200>(
      {url: `/api/v1/users/${address}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserByAddressQueryKey = (address?: string,) => {
    return [
    `/api/v1/users/${address}`
    ] as const;
    }

    
export const getGetUserByAddressQueryOptions = <TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByAddressQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByAddress>>> = ({ signal }) => getUserByAddress(address, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByAddress>>>
export type GetUserByAddressQueryError = unknown


export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAddress>>,
          TError,
          Awaited<ReturnType<typeof getUserByAddress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAddress>>,
          TError,
          Awaited<ReturnType<typeof getUserByAddress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get public user profile
 */

export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByAddressQueryOptions(address,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetUserByAddressSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByAddressQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByAddress>>> = ({ signal }) => getUserByAddress(address, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByAddressSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByAddress>>>
export type GetUserByAddressSuspenseQueryError = unknown


export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get public user profile
 */

export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByAddressSuspenseQueryOptions(address,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get leaderboard
 */
export const getLeaderboard = (
    params?: GetLeaderboardParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetLeaderboard200>(
      {url: `/api/v1/leaderboard`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetLeaderboardQueryKey = (params?: GetLeaderboardParams,) => {
    return [
    `/api/v1/leaderboard`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetLeaderboardQueryOptions = <TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLeaderboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({ signal }) => getLeaderboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboard>>>
export type GetLeaderboardQueryError = unknown


export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params: undefined |  GetLeaderboardParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get leaderboard
 */

export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLeaderboardQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetLeaderboardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLeaderboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({ signal }) => getLeaderboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLeaderboardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboard>>>
export type GetLeaderboardSuspenseQueryError = unknown


export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params: undefined |  GetLeaderboardParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get leaderboard
 */

export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLeaderboardSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Connect wallet and register session
 */
export const connectWallet = (
    connectRequest: ConnectRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/auth/connect`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: connectRequest, signal
    },
      options);
    }
  


export const getConnectWalletMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext> => {

const mutationKey = ['connectWallet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof connectWallet>>, {data: ConnectRequest}> = (props) => {
          const {data} = props ?? {};

          return  connectWallet(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConnectWalletMutationResult = NonNullable<Awaited<ReturnType<typeof connectWallet>>>
    export type ConnectWalletMutationBody = ConnectRequest
    export type ConnectWalletMutationError = unknown

    /**
 * @summary Connect wallet and register session
 */
export const useConnectWallet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof connectWallet>>,
        TError,
        {data: ConnectRequest},
        TContext
      > => {

      const mutationOptions = getConnectWalletMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Check authz and feegrant status
 */
export const getGrantStatus = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetGrantStatus200>(
      {url: `/api/v1/auth/grants`, method: 'GET', signal
    },
      options);
    }
  



export const getGetGrantStatusQueryKey = () => {
    return [
    `/api/v1/auth/grants`
    ] as const;
    }

    
export const getGetGrantStatusQueryOptions = <TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGrantStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGrantStatus>>> = ({ signal }) => getGrantStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGrantStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getGrantStatus>>>
export type GetGrantStatusQueryError = unknown


export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGrantStatus>>,
          TError,
          Awaited<ReturnType<typeof getGrantStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGrantStatus>>,
          TError,
          Awaited<ReturnType<typeof getGrantStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check authz and feegrant status
 */

export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGrantStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetGrantStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGrantStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGrantStatus>>> = ({ signal }) => getGrantStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGrantStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGrantStatus>>>
export type GetGrantStatusSuspenseQueryError = unknown


export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check authz and feegrant status
 */

export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGrantStatusSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List active events
 */
export const getActiveEvents = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetActiveEvents200>(
      {url: `/api/v1/events/active`, method: 'GET', signal
    },
      options);
    }
  



export const getGetActiveEventsQueryKey = () => {
    return [
    `/api/v1/events/active`
    ] as const;
    }

    
export const getGetActiveEventsQueryOptions = <TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveEvents>>> = ({ signal }) => getActiveEvents(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveEvents>>>
export type GetActiveEventsQueryError = unknown


export function useGetActiveEvents<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveEvents>>,
          TError,
          Awaited<ReturnType<typeof getActiveEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveEvents<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveEvents>>,
          TError,
          Awaited<ReturnType<typeof getActiveEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveEvents<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List active events
 */

export function useGetActiveEvents<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveEventsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetActiveEventsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveEvents>>> = ({ signal }) => getActiveEvents(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveEventsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveEvents>>>
export type GetActiveEventsSuspenseQueryError = unknown


export function useGetActiveEventsSuspense<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveEventsSuspense<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveEventsSuspense<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List active events
 */

export function useGetActiveEventsSuspense<TData = Awaited<ReturnType<typeof getActiveEvents>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActiveEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveEventsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List completed events
 */
export const getCompletedEvents = (
    params?: GetCompletedEventsParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetCompletedEvents200>(
      {url: `/api/v1/events/completed`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetCompletedEventsQueryKey = (params?: GetCompletedEventsParams,) => {
    return [
    `/api/v1/events/completed`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCompletedEventsQueryOptions = <TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(params?: GetCompletedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompletedEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedEvents>>> = ({ signal }) => getCompletedEvents(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCompletedEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedEvents>>>
export type GetCompletedEventsQueryError = unknown


export function useGetCompletedEvents<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params: undefined |  GetCompletedEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedEvents>>,
          TError,
          Awaited<ReturnType<typeof getCompletedEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedEvents<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedEvents>>,
          TError,
          Awaited<ReturnType<typeof getCompletedEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedEvents<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List completed events
 */

export function useGetCompletedEvents<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCompletedEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetCompletedEventsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(params?: GetCompletedEventsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompletedEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedEvents>>> = ({ signal }) => getCompletedEvents(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCompletedEventsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedEvents>>>
export type GetCompletedEventsSuspenseQueryError = unknown


export function useGetCompletedEventsSuspense<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params: undefined |  GetCompletedEventsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedEventsSuspense<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedEventsSuspense<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List completed events
 */

export function useGetCompletedEventsSuspense<TData = Awaited<ReturnType<typeof getCompletedEvents>>, TError = unknown>(
 params?: GetCompletedEventsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCompletedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCompletedEventsSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get event details
 */
export const getEventById = (
    eventId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetEventById200>(
      {url: `/api/v1/events/${eventId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEventByIdQueryKey = (eventId?: string,) => {
    return [
    `/api/v1/events/${eventId}`
    ] as const;
    }

    
export const getGetEventByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventByIdQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventById>>> = ({ signal }) => getEventById(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEventById>>>
export type GetEventByIdQueryError = ErrorResponse


export function useGetEventById<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventById>>,
          TError,
          Awaited<ReturnType<typeof getEventById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventById<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventById>>,
          TError,
          Awaited<ReturnType<typeof getEventById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventById<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event details
 */

export function useGetEventById<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventByIdQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetEventByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventByIdQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventById>>> = ({ signal }) => getEventById(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEventById>>>
export type GetEventByIdSuspenseQueryError = ErrorResponse


export function useGetEventByIdSuspense<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventByIdSuspense<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventByIdSuspense<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event details
 */

export function useGetEventByIdSuspense<TData = Awaited<ReturnType<typeof getEventById>>, TError = ErrorResponse>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventByIdSuspenseQueryOptions(eventId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get contest leaderboard
 */
export const getEventLeaderboard = (
    eventId: string,
    params?: GetEventLeaderboardParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetEventLeaderboard200>(
      {url: `/api/v1/events/${eventId}/leaderboard`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetEventLeaderboardQueryKey = (eventId?: string,
    params?: GetEventLeaderboardParams,) => {
    return [
    `/api/v1/events/${eventId}/leaderboard`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetEventLeaderboardQueryOptions = <TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventLeaderboardQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventLeaderboard>>> = ({ signal }) => getEventLeaderboard(eventId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof getEventLeaderboard>>>
export type GetEventLeaderboardQueryError = unknown


export function useGetEventLeaderboard<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params: undefined |  GetEventLeaderboardParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getEventLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventLeaderboard<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getEventLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventLeaderboard<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get contest leaderboard
 */

export function useGetEventLeaderboard<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventLeaderboardQueryOptions(eventId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetEventLeaderboardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventLeaderboardQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventLeaderboard>>> = ({ signal }) => getEventLeaderboard(eventId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventLeaderboardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEventLeaderboard>>>
export type GetEventLeaderboardSuspenseQueryError = unknown


export function useGetEventLeaderboardSuspense<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params: undefined |  GetEventLeaderboardParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventLeaderboardSuspense<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventLeaderboardSuspense<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get contest leaderboard
 */

export function useGetEventLeaderboardSuspense<TData = Awaited<ReturnType<typeof getEventLeaderboard>>, TError = unknown>(
 eventId: string,
    params?: GetEventLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventLeaderboardSuspenseQueryOptions(eventId,params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get raffle participants
 */
export const getEventParticipants = (
    eventId: string,
    params?: GetEventParticipantsParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetEventParticipants200>(
      {url: `/api/v1/events/${eventId}/participants`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetEventParticipantsQueryKey = (eventId?: string,
    params?: GetEventParticipantsParams,) => {
    return [
    `/api/v1/events/${eventId}/participants`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetEventParticipantsQueryOptions = <TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventParticipantsQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventParticipants>>> = ({ signal }) => getEventParticipants(eventId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventParticipantsQueryResult = NonNullable<Awaited<ReturnType<typeof getEventParticipants>>>
export type GetEventParticipantsQueryError = unknown


export function useGetEventParticipants<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params: undefined |  GetEventParticipantsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventParticipants>>,
          TError,
          Awaited<ReturnType<typeof getEventParticipants>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventParticipants<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventParticipants>>,
          TError,
          Awaited<ReturnType<typeof getEventParticipants>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventParticipants<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get raffle participants
 */

export function useGetEventParticipants<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventParticipantsQueryOptions(eventId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetEventParticipantsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventParticipantsQueryKey(eventId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventParticipants>>> = ({ signal }) => getEventParticipants(eventId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventParticipantsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEventParticipants>>>
export type GetEventParticipantsSuspenseQueryError = unknown


export function useGetEventParticipantsSuspense<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params: undefined |  GetEventParticipantsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventParticipantsSuspense<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventParticipantsSuspense<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get raffle participants
 */

export function useGetEventParticipantsSuspense<TData = Awaited<ReturnType<typeof getEventParticipants>>, TError = unknown>(
 eventId: string,
    params?: GetEventParticipantsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventParticipants>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventParticipantsSuspenseQueryOptions(eventId,params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get event results
 */
export const getEventResults = (
    eventId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/events/${eventId}/results`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEventResultsQueryKey = (eventId?: string,) => {
    return [
    `/api/v1/events/${eventId}/results`
    ] as const;
    }

    
export const getGetEventResultsQueryOptions = <TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventResultsQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventResults>>> = ({ signal }) => getEventResults(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventResultsQueryResult = NonNullable<Awaited<ReturnType<typeof getEventResults>>>
export type GetEventResultsQueryError = unknown


export function useGetEventResults<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventResults>>,
          TError,
          Awaited<ReturnType<typeof getEventResults>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventResults<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventResults>>,
          TError,
          Awaited<ReturnType<typeof getEventResults>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventResults<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event results
 */

export function useGetEventResults<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventResultsQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetEventResultsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventResultsQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventResults>>> = ({ signal }) => getEventResults(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventResultsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEventResults>>>
export type GetEventResultsSuspenseQueryError = unknown


export function useGetEventResultsSuspense<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventResultsSuspense<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventResultsSuspense<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get event results
 */

export function useGetEventResultsSuspense<TData = Awaited<ReturnType<typeof getEventResults>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEventResults>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventResultsSuspenseQueryOptions(eventId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Join event (raffle or opt-in contest)
 */
export const joinEvent = (
    eventId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/events/${eventId}/join`, method: 'POST', signal
    },
      options);
    }
  


export const getJoinEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: string}, TContext> => {

const mutationKey = ['joinEvent'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joinEvent>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  joinEvent(eventId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JoinEventMutationResult = NonNullable<Awaited<ReturnType<typeof joinEvent>>>
    
    export type JoinEventMutationError = unknown

    /**
 * @summary Join event (raffle or opt-in contest)
 */
export const useJoinEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof joinEvent>>,
        TError,
        {eventId: string},
        TContext
      > => {

      const mutationOptions = getJoinEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current user event status
 */
export const getMyEventStatus = (
    eventId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/events/${eventId}/my-status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMyEventStatusQueryKey = (eventId?: string,) => {
    return [
    `/api/v1/events/${eventId}/my-status`
    ] as const;
    }

    
export const getGetMyEventStatusQueryOptions = <TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyEventStatusQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyEventStatus>>> = ({ signal }) => getMyEventStatus(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyEventStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getMyEventStatus>>>
export type GetMyEventStatusQueryError = unknown


export function useGetMyEventStatus<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyEventStatus>>,
          TError,
          Awaited<ReturnType<typeof getMyEventStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyEventStatus<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyEventStatus>>,
          TError,
          Awaited<ReturnType<typeof getMyEventStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyEventStatus<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user event status
 */

export function useGetMyEventStatus<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyEventStatusQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetMyEventStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyEventStatusQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyEventStatus>>> = ({ signal }) => getMyEventStatus(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyEventStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMyEventStatus>>>
export type GetMyEventStatusSuspenseQueryError = unknown


export function useGetMyEventStatusSuspense<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyEventStatusSuspense<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyEventStatusSuspense<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user event status
 */

export function useGetMyEventStatusSuspense<TData = Awaited<ReturnType<typeof getMyEventStatus>>, TError = unknown>(
 eventId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyEventStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyEventStatusSuspenseQueryOptions(eventId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
