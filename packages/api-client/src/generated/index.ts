/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * CoinFlip PvP dApp API
 * API for the PvP CoinFlip decentralized application on Axiome Chain. Enables creating, accepting, revealing, and resolving Heads/Tails bets with LAUNCH tokens.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import { customFetch } from '../custom-fetch';
/**
 * Current bet status
 */
export type BetStatus = typeof BetStatus[keyof typeof BetStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BetStatus = {
  open: 'open',
  accepting: 'accepting',
  accepted: 'accepted',
  revealed: 'revealed',
  canceled: 'canceled',
  timeout_claimed: 'timeout_claimed',
} as const;

/**
 * Acceptor address (null if OPEN)
 * @minLength 1
 */
export type BetAcceptor = string | null;

/**
 * Acceptor guess (null if OPEN)
 */
export type BetAcceptorGuess = 'heads' | 'tails' | null;

export type BetAcceptedAt = string | null;

/**
 * Transaction hash
 */
export type BetTxhashAccept = string | null;

/**
 * Maker revealed side
 */
export type BetRevealSide = 'heads' | 'tails' | null;

/**
 * Winner address
 * @minLength 1
 */
export type BetWinner = string | null;

/**
 * Winner payout (after commission)
 * @pattern ^\d+$
 */
export type BetPayoutAmount = string | null;

/**
 * Token amount as string
 * @pattern ^\d+$
 */
export type BetCommissionAmount = string | null;

export type BetResolvedAt = string | null;

/**
 * Transaction hash
 */
export type BetTxhashResolve = string | null;

/**
 * Deadline for maker to reveal (accepted_at + 5min)
 */
export type BetRevealDeadline = string | null;

export interface Bet {
  /**
   * Unique bet identifier
   */
  id: number;
  /**
   * Axiome wallet address
   * @minLength 1
   */
  maker: string;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  amount: string;
  /** Current bet status */
  status: BetStatus;
  /** Bet creation time (ISO 8601) */
  created_at: string;
  /** Transaction hash */
  txhash_create: string;
  /**
   * Acceptor address (null if OPEN)
   * @minLength 1
   */
  acceptor: BetAcceptor;
  /** Acceptor guess (null if OPEN) */
  acceptor_guess: BetAcceptorGuess;
  accepted_at: BetAcceptedAt;
  /** Transaction hash */
  txhash_accept: BetTxhashAccept;
  /** Maker revealed side */
  reveal_side: BetRevealSide;
  /**
   * Winner address
   * @minLength 1
   */
  winner: BetWinner;
  /**
   * Winner payout (after commission)
   * @pattern ^\d+$
   */
  payout_amount: BetPayoutAmount;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  commission_amount: BetCommissionAmount;
  resolved_at: BetResolvedAt;
  /** Transaction hash */
  txhash_resolve: BetTxhashResolve;
  /** Deadline for maker to reveal (accepted_at + 5min) */
  reveal_deadline: BetRevealDeadline;
}

export interface CreateBetRequest {
  /**
   * Bet amount in LAUNCH tokens
   * @pattern ^\d+$
   */
  amount: string;
}

/**
 * Additional error details
 */
export type ErrorResponseErrorDetails = {[key: string]: unknown};

export type ErrorResponseError = {
  /** Machine-readable error code */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  details?: ErrorResponseErrorDetails;
};

export interface ErrorResponse {
  error: ErrorResponseError;
}

/**
 * Acceptor guess: heads or tails
 */
export type AcceptBetRequestGuess = typeof AcceptBetRequestGuess[keyof typeof AcceptBetRequestGuess];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AcceptBetRequestGuess = {
  heads: 'heads',
  tails: 'tails',
} as const;

export interface AcceptBetRequest {
  /** Acceptor guess: heads or tails */
  guess: AcceptBetRequestGuess;
}

/**
 * Maker original chosen side
 */
export type RevealRequestSide = typeof RevealRequestSide[keyof typeof RevealRequestSide];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RevealRequestSide = {
  heads: 'heads',
  tails: 'tails',
} as const;

export interface RevealRequest {
  /** Maker original chosen side */
  side: RevealRequestSide;
  /**
   * Original secret (64 hex chars = 32 bytes)
   * @minLength 64
   * @maxLength 64
   */
  secret: string;
}

export interface VaultBalance {
  /**
   * Available balance (not locked)
   * @pattern ^\d+$
   */
  available: string;
  /**
   * Locked in active bets
   * @pattern ^\d+$
   */
  locked: string;
  /**
   * Total vault balance
   * @pattern ^\d+$
   */
  total: string;
}

export interface DepositRequest {
  /**
   * Amount of LAUNCH to deposit
   * @pattern ^\d+$
   */
  amount: string;
}

export interface WithdrawRequest {
  /**
   * Amount of LAUNCH to withdraw
   * @pattern ^\d+$
   */
  amount: string;
}

/**
 * Display name
 */
export type UserProfileNickname = string | null;

/**
 * Avatar image URL
 */
export type UserProfileAvatarUrl = string | null;

export type UserProfileStats = {
  /** Total bets placed */
  total_bets: number;
  /** Total wins */
  wins: number;
  /** Total losses */
  losses: number;
  /**
   * Total LAUNCH wagered
   * @pattern ^\d+$
   */
  total_wagered: string;
  /**
   * Total LAUNCH won
   * @pattern ^\d+$
   */
  total_won: string;
};

/**
 * Authz grant expiration
 */
export type UserProfileAuthzExpiresAt = string | null;

export interface UserProfile {
  /**
   * Axiome wallet address
   * @minLength 1
   */
  address: string;
  /** Display name */
  nickname: UserProfileNickname;
  /** Avatar image URL */
  avatar_url: UserProfileAvatarUrl;
  stats: UserProfileStats;
  /** 1-click mode active */
  authz_enabled: boolean;
  /** Authz grant expiration */
  authz_expires_at: UserProfileAuthzExpiresAt;
  /** Gas sponsorship active */
  fee_sponsored: boolean;
}

export type LeaderboardEntryNickname = string | null;

export interface LeaderboardEntry {
  rank: number;
  /**
   * Axiome wallet address
   * @minLength 1
   */
  address: string;
  nickname: LeaderboardEntryNickname;
  wins: number;
  /**
   * Token amount as string
   * @pattern ^\d+$
   */
  total_wagered: string;
  /** Win rate 0-1 */
  win_rate: number;
}

export interface ConnectRequest {
  /**
   * User wallet address
   * @minLength 1
   */
  address: string;
  /** Signed message proving ownership */
  signature?: string;
  /** Original signed message */
  message?: string;
}

export type GrantStatusAuthzExpiresAt = string | null;

export type GrantStatusAuthzCallsRemaining = number | null;

/**
 * Remaining daily fee allowance
 */
export type GrantStatusFeeGrantDailyRemaining = string | null;

export interface GrantStatus {
  /** Authz grant exists and is valid */
  authz_granted: boolean;
  authz_expires_at: GrantStatusAuthzExpiresAt;
  authz_calls_remaining: GrantStatusAuthzCallsRemaining;
  /** Feegrant is active */
  fee_grant_active: boolean;
  /** Remaining daily fee allowance */
  fee_grant_daily_remaining: GrantStatusFeeGrantDailyRemaining;
}

export type GetBetsParams = {
status?: GetBetsStatus;
min_amount?: string;
max_amount?: string;
cursor?: string;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type GetBetsStatus = typeof GetBetsStatus[keyof typeof GetBetsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetBetsStatus = {
  open: 'open',
  accepting: 'accepting',
  accepted: 'accepted',
  revealed: 'revealed',
  canceled: 'canceled',
  timeout_claimed: 'timeout_claimed',
} as const;

export type GetBets200Cursor = string | null;

export type GetBets200 = {
  data: Bet[];
  cursor: GetBets200Cursor;
  has_more: boolean;
};

export type CreateBet201 = {
  data: Bet;
};

export type GetBetHistoryParams = {
address?: string;
cursor?: string;
limit?: number;
};

export type GetBetHistory200Cursor = string | null;

export type GetBetHistory200 = {
  data: Bet[];
  cursor: GetBetHistory200Cursor;
  has_more: boolean;
};

export type GetBetById200 = {
  data: Bet;
};

export type AcceptBet200 = {
  data: Bet;
};

export type RevealBet200 = {
  data: Bet;
};

export type CancelBet200 = {
  data: Bet;
};

export type ClaimTimeout200 = {
  data: Bet;
};

export type GetVaultBalance200 = {
  data: VaultBalance;
};

export type GetCurrentUser200 = {
  data: UserProfile;
};

export type GetUserByAddress200 = {
  data: UserProfile;
};

export type GetLeaderboardParams = {
cursor?: string;
limit?: number;
};

export type GetLeaderboard200Cursor = string | null;

export type GetLeaderboard200 = {
  data: LeaderboardEntry[];
  cursor: GetLeaderboard200Cursor;
  has_more: boolean;
};

export type GetGrantStatus200 = {
  data: GrantStatus;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List open bets
 */
export const getBets = (
    params?: GetBetsParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBets200>(
      {url: `/api/v1/bets`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetBetsQueryKey = (params?: GetBetsParams,) => {
    return [
    `/api/v1/bets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetBetsQueryOptions = <TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBets>>> = ({ signal }) => getBets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetsQueryResult = NonNullable<Awaited<ReturnType<typeof getBets>>>
export type GetBetsQueryError = unknown


export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params: undefined |  GetBetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBets>>,
          TError,
          Awaited<ReturnType<typeof getBets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBets>>,
          TError,
          Awaited<ReturnType<typeof getBets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List open bets
 */

export function useGetBets<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBets>>> = ({ signal }) => getBets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBets>>>
export type GetBetsSuspenseQueryError = unknown


export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params: undefined |  GetBetsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List open bets
 */

export function useGetBetsSuspense<TData = Awaited<ReturnType<typeof getBets>>, TError = unknown>(
 params?: GetBetsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetsSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create a new bet
 */
export const createBet = (
    createBetRequest: CreateBetRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CreateBet201>(
      {url: `/api/v1/bets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBetRequest, signal
    },
      options);
    }
  


export const getCreateBetMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext> => {

const mutationKey = ['createBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBet>>, {data: CreateBetRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBet(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBetMutationResult = NonNullable<Awaited<ReturnType<typeof createBet>>>
    export type CreateBetMutationBody = CreateBetRequest
    export type CreateBetMutationError = ErrorResponse

    /**
 * @summary Create a new bet
 */
export const useCreateBet = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBet>>, TError,{data: CreateBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBet>>,
        TError,
        {data: CreateBetRequest},
        TContext
      > => {

      const mutationOptions = getCreateBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get bet history
 */
export const getBetHistory = (
    params?: GetBetHistoryParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBetHistory200>(
      {url: `/api/v1/bets/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetBetHistoryQueryKey = (params?: GetBetHistoryParams,) => {
    return [
    `/api/v1/bets/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetBetHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetHistory>>> = ({ signal }) => getBetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getBetHistory>>>
export type GetBetHistoryQueryError = unknown


export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params: undefined |  GetBetHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetHistory>>,
          TError,
          Awaited<ReturnType<typeof getBetHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetHistory>>,
          TError,
          Awaited<ReturnType<typeof getBetHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet history
 */

export function useGetBetHistory<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetHistorySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetHistory>>> = ({ signal }) => getBetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetHistorySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBetHistory>>>
export type GetBetHistorySuspenseQueryError = unknown


export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params: undefined |  GetBetHistoryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet history
 */

export function useGetBetHistorySuspense<TData = Awaited<ReturnType<typeof getBetHistory>>, TError = unknown>(
 params?: GetBetHistoryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetHistory>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetHistorySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get bet details
 */
export const getBetById = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetBetById200>(
      {url: `/api/v1/bets/${betId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetBetByIdQueryKey = (betId?: number,) => {
    return [
    `/api/v1/bets/${betId}`
    ] as const;
    }

    
export const getGetBetByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetByIdQueryKey(betId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetById>>> = ({ signal }) => getBetById(betId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(betId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBetById>>>
export type GetBetByIdQueryError = ErrorResponse


export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetById>>,
          TError,
          Awaited<ReturnType<typeof getBetById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetById>>,
          TError,
          Awaited<ReturnType<typeof getBetById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet details
 */

export function useGetBetById<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetByIdQueryOptions(betId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetBetByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBetByIdQueryKey(betId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetById>>> = ({ signal }) => getBetById(betId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBetByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getBetById>>>
export type GetBetByIdSuspenseQueryError = ErrorResponse


export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bet details
 */

export function useGetBetByIdSuspense<TData = Awaited<ReturnType<typeof getBetById>>, TError = ErrorResponse>(
 betId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getBetById>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBetByIdSuspenseQueryOptions(betId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Accept an open bet
 */
export const acceptBet = (
    betId: number,
    acceptBetRequest: AcceptBetRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<AcceptBet200>(
      {url: `/api/v1/bets/${betId}/accept`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: acceptBetRequest, signal
    },
      options);
    }
  


export const getAcceptBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext> => {

const mutationKey = ['acceptBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptBet>>, {betId: number;data: AcceptBetRequest}> = (props) => {
          const {betId,data} = props ?? {};

          return  acceptBet(betId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AcceptBetMutationResult = NonNullable<Awaited<ReturnType<typeof acceptBet>>>
    export type AcceptBetMutationBody = AcceptBetRequest
    export type AcceptBetMutationError = unknown

    /**
 * @summary Accept an open bet
 */
export const useAcceptBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof acceptBet>>, TError,{betId: number;data: AcceptBetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof acceptBet>>,
        TError,
        {betId: number;data: AcceptBetRequest},
        TContext
      > => {

      const mutationOptions = getAcceptBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Reveal commitment for accepted bet
 */
export const revealBet = (
    betId: number,
    revealRequest: RevealRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<RevealBet200>(
      {url: `/api/v1/bets/${betId}/reveal`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: revealRequest, signal
    },
      options);
    }
  


export const getRevealBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext> => {

const mutationKey = ['revealBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof revealBet>>, {betId: number;data: RevealRequest}> = (props) => {
          const {betId,data} = props ?? {};

          return  revealBet(betId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RevealBetMutationResult = NonNullable<Awaited<ReturnType<typeof revealBet>>>
    export type RevealBetMutationBody = RevealRequest
    export type RevealBetMutationError = unknown

    /**
 * @summary Reveal commitment for accepted bet
 */
export const useRevealBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revealBet>>, TError,{betId: number;data: RevealRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof revealBet>>,
        TError,
        {betId: number;data: RevealRequest},
        TContext
      > => {

      const mutationOptions = getRevealBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Cancel an open bet
 */
export const cancelBet = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CancelBet200>(
      {url: `/api/v1/bets/${betId}/cancel`, method: 'POST', signal
    },
      options);
    }
  


export const getCancelBetMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext> => {

const mutationKey = ['cancelBet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelBet>>, {betId: number}> = (props) => {
          const {betId} = props ?? {};

          return  cancelBet(betId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelBetMutationResult = NonNullable<Awaited<ReturnType<typeof cancelBet>>>
    
    export type CancelBetMutationError = unknown

    /**
 * @summary Cancel an open bet
 */
export const useCancelBet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBet>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelBet>>,
        TError,
        {betId: number},
        TContext
      > => {

      const mutationOptions = getCancelBetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Claim timeout on unrevealed bet
 */
export const claimTimeout = (
    betId: number,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<ClaimTimeout200>(
      {url: `/api/v1/bets/${betId}/claim-timeout`, method: 'POST', signal
    },
      options);
    }
  


export const getClaimTimeoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext> => {

const mutationKey = ['claimTimeout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof claimTimeout>>, {betId: number}> = (props) => {
          const {betId} = props ?? {};

          return  claimTimeout(betId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClaimTimeoutMutationResult = NonNullable<Awaited<ReturnType<typeof claimTimeout>>>
    
    export type ClaimTimeoutMutationError = unknown

    /**
 * @summary Claim timeout on unrevealed bet
 */
export const useClaimTimeout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimTimeout>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof claimTimeout>>,
        TError,
        {betId: number},
        TContext
      > => {

      const mutationOptions = getClaimTimeoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current vault balance
 */
export const getVaultBalance = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetVaultBalance200>(
      {url: `/api/v1/vault/balance`, method: 'GET', signal
    },
      options);
    }
  



export const getGetVaultBalanceQueryKey = () => {
    return [
    `/api/v1/vault/balance`
    ] as const;
    }

    
export const getGetVaultBalanceQueryOptions = <TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVaultBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVaultBalance>>> = ({ signal }) => getVaultBalance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVaultBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getVaultBalance>>>
export type GetVaultBalanceQueryError = unknown


export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVaultBalance>>,
          TError,
          Awaited<ReturnType<typeof getVaultBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVaultBalance>>,
          TError,
          Awaited<ReturnType<typeof getVaultBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current vault balance
 */

export function useGetVaultBalance<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVaultBalanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetVaultBalanceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVaultBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVaultBalance>>> = ({ signal }) => getVaultBalance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVaultBalanceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getVaultBalance>>>
export type GetVaultBalanceSuspenseQueryError = unknown


export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current vault balance
 */

export function useGetVaultBalanceSuspense<TData = Awaited<ReturnType<typeof getVaultBalance>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getVaultBalance>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVaultBalanceSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Initiate deposit (returns Axiome Connect payload)
 */
export const depositToVault = (
    depositRequest: DepositRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/vault/deposit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: depositRequest, signal
    },
      options);
    }
  


export const getDepositToVaultMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext> => {

const mutationKey = ['depositToVault'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof depositToVault>>, {data: DepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  depositToVault(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DepositToVaultMutationResult = NonNullable<Awaited<ReturnType<typeof depositToVault>>>
    export type DepositToVaultMutationBody = DepositRequest
    export type DepositToVaultMutationError = unknown

    /**
 * @summary Initiate deposit (returns Axiome Connect payload)
 */
export const useDepositToVault = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof depositToVault>>, TError,{data: DepositRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof depositToVault>>,
        TError,
        {data: DepositRequest},
        TContext
      > => {

      const mutationOptions = getDepositToVaultMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Withdraw LAUNCH from vault
 */
export const withdrawFromVault = (
    withdrawRequest: WithdrawRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/vault/withdraw`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: withdrawRequest, signal
    },
      options);
    }
  


export const getWithdrawFromVaultMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext> => {

const mutationKey = ['withdrawFromVault'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdrawFromVault>>, {data: WithdrawRequest}> = (props) => {
          const {data} = props ?? {};

          return  withdrawFromVault(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawFromVaultMutationResult = NonNullable<Awaited<ReturnType<typeof withdrawFromVault>>>
    export type WithdrawFromVaultMutationBody = WithdrawRequest
    export type WithdrawFromVaultMutationError = unknown

    /**
 * @summary Withdraw LAUNCH from vault
 */
export const useWithdrawFromVault = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawFromVault>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdrawFromVault>>,
        TError,
        {data: WithdrawRequest},
        TContext
      > => {

      const mutationOptions = getWithdrawFromVaultMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get current user profile
 */
export const getCurrentUser = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetCurrentUser200>(
      {url: `/api/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/v1/users/me`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = unknown


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user profile
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetCurrentUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserSuspenseQueryError = unknown


export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user profile
 */

export function useGetCurrentUserSuspense<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get public user profile
 */
export const getUserByAddress = (
    address: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetUserByAddress200>(
      {url: `/api/v1/users/${address}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserByAddressQueryKey = (address?: string,) => {
    return [
    `/api/v1/users/${address}`
    ] as const;
    }

    
export const getGetUserByAddressQueryOptions = <TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByAddressQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByAddress>>> = ({ signal }) => getUserByAddress(address, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByAddress>>>
export type GetUserByAddressQueryError = unknown


export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAddress>>,
          TError,
          Awaited<ReturnType<typeof getUserByAddress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAddress>>,
          TError,
          Awaited<ReturnType<typeof getUserByAddress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get public user profile
 */

export function useGetUserByAddress<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByAddressQueryOptions(address,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetUserByAddressSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByAddressQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByAddress>>> = ({ signal }) => getUserByAddress(address, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByAddressSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByAddress>>>
export type GetUserByAddressSuspenseQueryError = unknown


export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get public user profile
 */

export function useGetUserByAddressSuspense<TData = Awaited<ReturnType<typeof getUserByAddress>>, TError = unknown>(
 address: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserByAddress>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByAddressSuspenseQueryOptions(address,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get leaderboard
 */
export const getLeaderboard = (
    params?: GetLeaderboardParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetLeaderboard200>(
      {url: `/api/v1/leaderboard`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetLeaderboardQueryKey = (params?: GetLeaderboardParams,) => {
    return [
    `/api/v1/leaderboard`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetLeaderboardQueryOptions = <TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLeaderboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({ signal }) => getLeaderboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboard>>>
export type GetLeaderboardQueryError = unknown


export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params: undefined |  GetLeaderboardParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get leaderboard
 */

export function useGetLeaderboard<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLeaderboardQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetLeaderboardSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLeaderboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({ signal }) => getLeaderboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLeaderboardSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboard>>>
export type GetLeaderboardSuspenseQueryError = unknown


export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params: undefined |  GetLeaderboardParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get leaderboard
 */

export function useGetLeaderboardSuspense<TData = Awaited<ReturnType<typeof getLeaderboard>>, TError = unknown>(
 params?: GetLeaderboardParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLeaderboardSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Connect wallet and register session
 */
export const connectWallet = (
    connectRequest: ConnectRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/auth/connect`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: connectRequest, signal
    },
      options);
    }
  


export const getConnectWalletMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext> => {

const mutationKey = ['connectWallet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof connectWallet>>, {data: ConnectRequest}> = (props) => {
          const {data} = props ?? {};

          return  connectWallet(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConnectWalletMutationResult = NonNullable<Awaited<ReturnType<typeof connectWallet>>>
    export type ConnectWalletMutationBody = ConnectRequest
    export type ConnectWalletMutationError = unknown

    /**
 * @summary Connect wallet and register session
 */
export const useConnectWallet = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWallet>>, TError,{data: ConnectRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof connectWallet>>,
        TError,
        {data: ConnectRequest},
        TContext
      > => {

      const mutationOptions = getConnectWalletMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Check authz and feegrant status
 */
export const getGrantStatus = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetGrantStatus200>(
      {url: `/api/v1/auth/grants`, method: 'GET', signal
    },
      options);
    }
  



export const getGetGrantStatusQueryKey = () => {
    return [
    `/api/v1/auth/grants`
    ] as const;
    }

    
export const getGetGrantStatusQueryOptions = <TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGrantStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGrantStatus>>> = ({ signal }) => getGrantStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGrantStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getGrantStatus>>>
export type GetGrantStatusQueryError = unknown


export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGrantStatus>>,
          TError,
          Awaited<ReturnType<typeof getGrantStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGrantStatus>>,
          TError,
          Awaited<ReturnType<typeof getGrantStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check authz and feegrant status
 */

export function useGetGrantStatus<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGrantStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetGrantStatusSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGrantStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGrantStatus>>> = ({ signal }) => getGrantStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGrantStatusSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGrantStatus>>>
export type GetGrantStatusSuspenseQueryError = unknown


export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check authz and feegrant status
 */

export function useGetGrantStatusSuspense<TData = Awaited<ReturnType<typeof getGrantStatus>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGrantStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGrantStatusSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
